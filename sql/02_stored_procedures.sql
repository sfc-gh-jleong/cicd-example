USE ROLE SYSADMIN;
USE DATABASE CICD;
USE SCHEMA ETL;

CREATE OR REPLACE PROCEDURE ETL.EXTRACT_AND_TRANSFORM()
RETURNS VARCHAR
LANGUAGE SQL
AS
$$
BEGIN
    INSERT INTO TRANSFORMED_DATA (ID, DATA_VALUE, TRANSFORMED_VALUE, PROCESSED_AT)
    SELECT 
        ID,
        DATA_VALUE,
        UPPER(DATA_VALUE) || '_PROCESSED',
        CURRENT_TIMESTAMP()
    FROM RAW_DATA
    WHERE PROCESSED = FALSE;
    
    UPDATE RAW_DATA SET PROCESSED = TRUE WHERE PROCESSED = FALSE;
    
    RETURN 'Extract and Transform completed successfully';
END;
$$;

CREATE OR REPLACE PROCEDURE ETL.AGGREGATE_DATA()
RETURNS VARCHAR
LANGUAGE SQL
AS
$$
BEGIN
    MERGE INTO AGGREGATED_DATA tgt
    USING (
        SELECT 
            CURRENT_DATE() AS REPORT_DATE,
            COUNT(*) AS RECORD_COUNT,
            CURRENT_TIMESTAMP() AS LAST_UPDATED
        FROM TRANSFORMED_DATA
        WHERE DATE(PROCESSED_AT) = CURRENT_DATE()
    ) src
    ON tgt.REPORT_DATE = src.REPORT_DATE
    WHEN MATCHED THEN UPDATE SET 
        RECORD_COUNT = src.RECORD_COUNT,
        LAST_UPDATED = src.LAST_UPDATED
    WHEN NOT MATCHED THEN INSERT (REPORT_DATE, RECORD_COUNT, LAST_UPDATED)
        VALUES (src.REPORT_DATE, src.RECORD_COUNT, src.LAST_UPDATED);
    
    RETURN 'Aggregation completed successfully';
END;
$$;

CREATE OR REPLACE PROCEDURE ETL.RUN_FULL_ETL_PIPELINE()
RETURNS VARCHAR
LANGUAGE SQL
AS
$$
DECLARE
    extract_result VARCHAR;
    aggregate_result VARCHAR;
BEGIN
    CALL EXTRACT_AND_TRANSFORM() INTO extract_result;
    CALL AGGREGATE_DATA() INTO aggregate_result;
    RETURN 'Full ETL Pipeline completed: ' || extract_result || ' | ' || aggregate_result;
END;
$$;
